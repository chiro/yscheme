;; datum
datum <- intertoken_space datum_aux intertoken_space
datum_aux <- simple_datum / compound_datum / label "=" datum / label "#"
simple_datum <- boolean / number / character / string / symbol / bytevector
symbol <- identifier
compound_datum <- list / vector
list <- "(" datum* ")" / "(" datum+ "." datum ")" / abbreviation
abbreviation <- abbrev_prefix datum
abbrev_prefix <- "'" / "`" / ",@" / ","
vector <- "#(" datum* ")"
label <- "#" digit10+

; token 
token <- identifier delimiter / boolean delimiter / number delimiter / character delimiter / string / "(" / ")" / "#(" / "\'" / "\`" / ",@" / "," / "."

delimiter <- whitespace / "(" / ")" / [\"] / ";"

; comment
comment <- (";" (!newline .)*) { (format t "comment\n") `(:comment ,(char-list-to-string (mapcar #'cadr (cadar data)))) } / nested_comment
nested_comment <- "#|" comment_text comment_cont* "|#"

comment_text <- (!comment_text_taboo .)* { (char-list-to-string (mapcar #'cadr (first data))) }
comment_text_taboo <- "#|" / "|#"
comment_cont <- nested_comment comment_text


;; spaces
atmosphere <- whitespace / comment
intertoken_space <- atmosphere*

whitespace <- (intraline_whitespace / newline / return)
newline <- [\n]
return <- [\r]
intraline_whitespace <- [ \t]
line_ending <- newline / return

backslash <- [\\]


;; identifier
identifier <- intertoken_space (initial subsequent* / "|" symbol_element* "|" / peculiar_identifier) delimiter
initial <- letter / special_initial / inline_hex_escape
letter <- [abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ]
special_initial <- [!$%&*/:<=>?^_~]
subsequent <- initial / digit / special_subsequent
digit <- [0123456789]
hex_digit <- digit / [abcdefABCDEF]

explicit_sign <- [\+\-]
special_subsequent <- explicit_sign / "." / "@"

inline_hex_escape <- backslash "x" hex_scalar_value ";"
hex_scalar_value <- hex_digit+

symbol_element <- !"|" !backslash .

non-digit <- dot_subsequent / explicit_sign
dot_subsequent <- sign_subsequent / "."
sign_subsequent <- initial / explicit_sign / "@"

peculiar_identifier <- explicit_sign / explicit_sign sign_subsequent subsequent* / explicit_sign "." dot_subsequent subsequent* / "." non-digit subsequent*

syntactic_keyword <- expression_keyword / "else" / "=>" / "define" / "unquote" / "unquote-splicing"
expression_keyword <- "quote" / "lambda" / "if" / "set!" / "begin" / "cond" / "and" / "or" / "case" / "let" / "let*" / "letrec" / "do" / "delay" / "quasiquote"

variable <- !syntactic_keyword identifier

;; ==================================================
;; boolean
;; ==================================================
boolean <- intertoken_space ("#t" / "#f") delimiter intertoken_space


;; ==================================================
;; character
;; ==================================================
character <- intertoken_space ("#\\" (character_name / .) / "#\\x" hex_scalar_value) delimiter
character_name <- "null" / "alarm" / "backspace" / "tab" / "newline" / "return" / "escape" / "space" / "delete"


;; ==================================================
;; string
;; ==================================================
string <- intertoken_space [\"] string_element* [\"]
string_element <- (![\"\\] .) / ([\\] [abtnr\"\\]) / [\\] intraline_whitespace line_ending intraline_whitespace / inline_hex_escape


;; ==================================================
;; bytevector
;; ==================================================
bytevector <- "#u8(" intertoken_space* (byte intertoken_space*)* ")"
byte <- digit+


;; ==================================================
;; numbers
;; ==================================================
number <- intertoken_space (num2 / num8 / num10 / num16) delimiter

num2 <- prefix2 complex2
complex2 <- real2 / real2 "@" real2 / real2 ("+" / "-") ureal2 "i" / real2 ("+" / "-") "i" / ("+" / "-") ureal2 "i" / ("+" / "-") "i"
real2 <- sign ureal2 / infinity
ureal2 <- uinteger2 / uinteger2 "/" uinteger2 / decimal2
decimal2 <- uinteger2 suffix / "." digit2+ "#"* suffix / digit2+ "." digit2* "#"* suffix / digit2+ "#"+ "." "#"* suffix
uinteger2 <- digit2+ "#"* { (parse-integer (char-list-to-string (car data)) :radix 2) }
prefix2 <- radix2 exactness / exactness radix2

num8 <- prefix8 complex8
complex8 <- real8 / real8 "@" real8 / real8 ("+" / "-") ureal8 "i" / real8 ("+" / "-") "i" / ("+" / "-") ureal8 "i" / ("+" / "-") "i"
real8 <- sign ureal8 / infinity
ureal8 <- uinteger8 / uinteger8 "/" uinteger8 / decimal8
decimal8 <- uinteger8 suffix / "." digit8+ "#"* suffix / digit8+ "." digit8* "#"* suffix / digit8+ "#"+ "." "#"* suffix
uinteger8 <- digit8+ "#"*
prefix8 <- radix8 exactness / exactness radix8

num10 <- prefix10 complex10
complex10 <- real10 / real10 "@" real10 / real10 ("+" / "-") ureal10 "i" / real10 ("+" / "-") "i" / ("+" / "-") ureal10 "i" / ("+" / "-") "i"
real10 <- sign ureal10 / infinity
ureal10 <- uinteger10 / uinteger10 "/" uinteger10 / decimal10
decimal10 <- uinteger10 suffix / "." digit10+ "#"* suffix / digit10+ "." digit10* "#"* suffix / digit10+ "#"+ "." "#"* suffix
uinteger10 <- digit10+ "#"* { (parse-integer (char-list-to-string (car data))) }
prefix10 <- radix10 exactness / exactness radix10

num16 <- prefix16 complex16
complex16 <- real16 / real16 "@" real16 / real16 ("+" / "-") ureal16 "i" / real16 ("+" / "-") "i" / ("+" / "-") ureal16 "i" / ("+" / "-") "i"
real16 <- sign ureal16 / infinity
ureal16 <- uinteger16 / uinteger16 "/" uinteger16 / decimal16
decimal16 <- uinteger16 suffix / "." digit16+ "#"* suffix / digit16+ "." digit16* "#"* suffix / digit16+ "#"+ "." "#"* suffix
uinteger16 <- digit16+ "#"*
prefix16 <- radix16 exactness / exactness radix16

infinity <- "+inf.0" { short-float-positive-infinity }
         / "-inf.0" { short-float-negaive-infinity }
         / "+nan.0"

suffix <- (exponent_marker sign digit10+)?
exponent_marker <- [esfdl]
sign <- ("+" / "-")?
exactness <- ("#i" / "#e")?
radix2 <- "#b"
radix8 <- "#o"
radix10 <- "#d"?
radix16 <- "#x"

digit2 <- "0" / "1"
digit8 <- [01234567]
digit10 <- digit
digit16 <- [0123456789abcdef]


;; ==================================================
;; expressions
;; ==================================================

expression <- variable / literal / procedure_call / lambda_expression / conditional / assignment / derived_expression / macro_use / macro_block

literal <- quotation / self_evaluating
self_evaluating <- boolean / number / character / string
quotation <- "\'" datum / "(" intertoken_space "quote" datum ")"
procedure_call <- "(" operator operand* ")"
operator <- expression
operand <- expression

lambda_expression <- "(" intertoken_space "lambda" formals body ")"
formals <- "(" variable* ")" / variable / "(" variable+ "." variable ")"
body <- syntax_definition* definition* sequence
sequence <- command* expression
command <- expression

conditional <- "(" intertoken_space "if" test consequent alternate ")"
test <- expression
consequent <- expression
alternate <- expression?

assignment <- "(" intertoken_space "set!" variable expression ")"


;; ==================================================
;; derived expressions
;; quasiquotation is not implemeted !!
;; ==================================================
itspc <- intertoken_space ;; aux

derived_expression <- "(" itspc "cond" cond_clause+ ")"
                   / "(" itspc "cond" cond_clause* "(" itspc "else" sequence ")" itspc ")"
                   / "(" itspc "case" expression case_clause+ ")"
                   / "(" itspc "case" expression case_clause* "(" itspc "else" sequence ")" itspc ")"
                   / "(" itspc "case" expression case_clause* "(" itspc "else" itspc "=>" recipient ")" itspc ")"
                   / "(" itspc "and" test* ")"
                   / "(" itspc "or" test* ")" / "(" itspc "when" expression body ")" 
                   / "(" itspc "unless" expression body ")"
                   / "(" itspc "let" itspc "(" binding_spec* ")" body ")" 
                   / "(" itspc "let" variable "(" binding_spec* ")" body ")"
                   / "(" itspc "let*" itspc "(" binding_spec* ")" body ")"
                   / "(" itspc "letrec" itspc "(" binding_spec* ")" body ")"
                   / "(" itspc "letrec*" itspc "(" binding_spec* ")" body ")"
                   / "(" itspc "let-values" itspc "(" formals* ")" body ")"
                   / "(" itspc "let*-values" itspc "(" formals* ")" body ")"
                   / "(" itspc "case-lambda" case-lambda_clause* ")"
                   / "(" itspc "begin" sequence ")"
                   / "(" itspc "do" itspc "(" iteration_spec* ")" itspc "(" test do_result ")" command* ")"
                   / "(" itspc "delay" expression ")"
                   / "(" itspc "lazy" expression ")"

cond_clause <- "(" test sequence ")"
            / "(" test ")"
            / "(" test "=>" recipient ")"
recipient <- expression
case_clause <- "(" itspc "(" datum* ")" sequence ")"
            / "(" itspc "(" datum* ")" itspc "=>" recipient ")"
binding_spec <- "(" variable expression ")"
iteration_spec <- "(" variable init step ")"
               /  "(" variable init ")"
case-lambda_clause <- "(" formals body ")"
init <- expression
step <- expression
do_result <- sequence?

macro_use <- "(" keyword datum* ")"
keyword <- identifier

macro_block <- "(" itspc "let-syntax" itspc "(" syntax_spec* ")" body ")"
            /  "(" itspc "letrec-syntax" itspc "(" syntax_spec* ")" body ")"
syntax_spec <- "(" keyword transformer_spec ")"


;; ==================================================
;; transformers -- macro
;; ==================================================
transformer_spec <- "(" itspc "syntax-rules" itspc "(" identifier* ")" syntax_rule* ")"
                 /  "(" itspc "syntax-rules" identifier "(" identifier* ")" syntax_rule* ")"
syntax_rule <- "(" pattern template ")"
pattern <- pattern_identifier
        /  "_"
        /  "(" pattern* ")"
        /  "(" pattern+ "." pattern ")"
        /  "(" pattern* pattern ellipsis pattern* ")"
        /  "(" pattern* pattern ellipsis pattern* "." pattern ")"
        /  "#(" pattern* ")"
        /  "#(" pattern* pattern ellipsis pattern* ")"
        /  pattern_datum

pattern_datum <- string / character / boolean / number
template <- pattern_identifier
         /  "(" template_element* ")"
         /  "(" template_element+ "." template ")"
         /  "#(" template_element* ")"
         /  template_datum
template_element <- template
                 / template ellipsis
template_datum <- pattern_datum
pattern_identifier <- !"..." identifier
ellipsis <- &identifier "..."
underscore <- "_"

;; ==================================================
;; programs and defnitions
;; ==================================================
program <- itspc (number itspc)*



command_or_definition <- definition
                      /  syntax_definition
                      /  command
;                      /  "(" itspc "import" import_set+ ")"
;                      /  "(" itspc "begin" command_or_definition+ ")"
definition <- "(" itspc "define" variable expression ")"
           /  "(" itspc "define" itspc "(" variable def_formals ")" body ")"
           /  "(" itspc "define-record-type" variable constructor variable field_spec* ")"
           /  "(" itspc "begin" definition* ")"
def_formals <- variable*
            /  variable* "." variable
constructor <- "(" variable field_name* ")"
field_spec <- "(" field_name variable ")"
field_name <- identifier
syntax_definition <- "(" itspc "define-syntax" keyword transformer_spec ")"
                  /  "(" itspc "begin" syntax_definition* ")"


;; ==================================================
;; Modules
;; ==================================================
;; module <- "(" itspc "module" itspc module_name module_declaration* ")"
;; module_name <- "(" module_name_part+ ")"
